>>> s = 'hello quant'
>>> repr(s)     #repr()： 产生一个解释器易读的表达形式。
"'hello quant'"
>>> a = bytes('中国',encoding = 'utf-8')
>>> a
b'\xe4\xb8\xad\xe5\x9b\xbd' #利用decode将之转换回中文
>>> a.decode()
'中国'
>>> 2 << 2  #将2往左移动两位,即200(二进制)转为10进制既是8
8
>>> 3 << 2
12
>>> 4 << 2
16
>>> 2 << 3
16
>>> 10 << 2 #即10*4
40
>>> 10 >> 2 #即10/4取整
2
>>> 2 << 1
4
>>> 11 >> 2 #即11/4取整
2
>>> 5&3
1
>>> 5&7  #数字的按位与
5
>>> 8 | 2  #数字的按位或
10
>>> 10 | 2
10
>>> 3 > 2 and 3 > 1
True
>>> 3 > 2 & 3> 8
False
>>> 0 & 7
0
>>> 10 & 11111
2
>>> ~2 
-3
>>> x = 100
>>> ~x  #按位反转
-101
>>> 5 ^ 2 #数字的按位XOR
7
>>> 5 ^ 3
6
>>> 14//3
4
>>> 14/3
4.666666666666667
>>> 14%3
2
>>> 8%2
0
>>> a = 1 + 2j
>>> a.real
1.0
>>> a.imag
2.0
>>> type(a)
<class 'complex'>
>>> 3/2
1.5
>>> 3%2
1
>>> 0.2+0.2
0.4
>>> 0.2+0.1
0.30000000000000004
>>> x = '     a   s  fdf  '
>>> x.replace(' ','')
'asfdf'
>>> b = 23
>>> print(f'{a} are {b} years old')
you are 23 years old
>>> print('{0:.3f}'.format(1.0/3))
0.333
>>> print('{0:_^11}'.format('hello'))
___hello___
>>> print(f'{a} love me')
you love me
>>> print('hello '+str(23)+'age')
hello 23age
>>> print('hello '+str(23)+' age')
hello 23 age
>>> '{0} love {1}.{2}'.format('i','fishc','com')
'i love fishc.com'
>>> '{a} love {b}.{c}'.format(a='i',b='fishc',c='com')
'i love fishc.com'
>>> '{0} love {b}.{c}'.format('i',b='fishc',c='com')
'i love fishc.com'
>>> '{0}'.format('hhh')
'hhh'
>>> '{{0}}'.format('hhh')
'{0}'
>>> '{0:1f}{1}'.format(17.77,'gb')
'17.770000gb'
>>> '%c'%97
'a'
>>> '%c %c %c'%(97,98,99)
'a b c'
>>> '%c'%100
'd'
>>> '%s'%'i love you'
'i love you'
>>> '%d + %d = %d'% (4,5,4+5)
'4 + 5 = 9'
>>> eval('234+234')
468
>>> eval('a')
'you'
>>> eval('b')
23
>>> print(r"Newlines are indicated by \n")
Newlines are indicated by \n
>>> print('newlines are indicated by \n')
newlines are indicated by 
>>> print(bool)
<class 'bool'>
>>> print(bool(False))
False
>>> print(bool(3>2))
True
>>> print(bool('3'))
True
>>> print(bool(0))
False
>>> print(bool(-23))
True
>>> print(bool(23))
True
>>> print(bool(None))
False
>>> print(bool([]))
False
>>> print(bool([23]))
True
>>> word = 'helloworld'
>>> newword = ','.join(word)
>>> newword
'h,e,l,l,o,w,o,r,l,d'
>>> print(u'书写national word') 
书写national word #Unicode是书写国际文本的标准方法。如果你想要用你的母语如北印度语或阿拉伯语写文本，那么你需要有一个支持Unicode的编辑器.
>>> print('书写national word')
书写national word
>>>try:
	a = int('0.5')
	print(a)
   except:
	print('error: convert "0.5" to int') %异常处理
   print('Done')
error: convert "0.5" to int
Done



>>> s = ';'
>>> li = ['apple','pear','banana']
>>> fruit = s.join(li)
>>> fruit
'apple;pear;banana'
>>> a =['me','i','mine']
>>> print(a[-1])
mine
>>> print('i love '+a[2])
i love mine
>>> a = ['i','me','mine']
>>> a
['i', 'me', 'mine']
>>> type(a)
<class 'list'>
>>> b = a[:]
>>> b
['i', 'me', 'mine']
>>> a
['i', 'me', 'mine']
>>> del b
>>> b
Traceback (most recent call last):
  File "<pyshell#30>", line 1, in <module>
    b
NameError: name 'b' is not defined
>>> a
['i', 'me', 'mine']
>>> b = a[0:2]
>>> b
['i', 'me']
>>> del b
>>> b = a
>>> b
['i', 'me', 'mine']
>>> del b
>>> b
Traceback (most recent call last):
  File "<pyshell#38>", line 1, in <module>
    b
NameError: name 'b' is not defined
>>> a
['i', 'me', 'mine']
>>> b
Traceback (most recent call last):
  File "<pyshell#40>", line 1, in <module>
    b
NameError: name 'b' is not defined
>>> b = a[:]
>>> b
['i', 'me', 'mine']
>>> b.append('you')
>>> b
['i', 'me', 'mine', 'you']
>>> a
['i', 'me', 'mine']
>>> b = a
>>> b
['i', 'me', 'mine']
>>> b.append('you')
>>> b
['i', 'me', 'mine', 'you']
>>> a
['i', 'me', 'mine', 'you']
>>> [(x,y) for x in [1,2,3] for y in [1,2,3]]
[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
>>> [x + 1 for x in [x**2 for x in [1,2,3]]]
[2, 5, 10]
>>> [(x,y) for (x,y) in zip([1,2,3],[3,1,2])]
[(1, 3), (2, 1), (3, 2)]
>>> l = ['hello','world',18,'apple',None]
>>> [s.lower() for s in l if isinstance(s,str)]
['hello', 'world', 'apple']
>>> g = (s.lower() for s in l if isinstance(s,str)) #把列表生成器的方括号换成圆括号就是生成器generator
>>> g
<generator object <genexpr> at 0x0000018EDF0BC948>
>>> next(g)
'hello'
>>> next(g)
'world'
>>> next(g)
'apple'
>>> next(g)  #生成器用next()调用，一次只调用一个，调用完元素就会报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> for i in g:  #因此一般用遍历来访问元素，此法不用管是否报错，此处已经next()完，故没有元素
...     print(i)
...
>>> def odd():
...     print('step 1')
...     yield 1
...     print('step 2')
...     yield 2
...     print('step 3')
...     yield 3
...
>>> o = odd()
>>> next(o)  #next()每一次会在执行过程中，遇到yield就中断，下次又继续执行
step 1
1
>>> next(o)
step 2
2
>>> def fib(max):
...     a,b,c = 0,0,1
...     while a < max:
...             yield c
...             b,c = c,b+c
...             a += 1
...     return 'done'
...
>>> f = fib(6)
>>> while True:
...     try:
...             x = next(f)
...             print('f:',x)
...     except StopIteration as e:#用for循环调用generator时，发现拿不到generator的return语句的返回值
...             print('Generator return value:',e.value) #如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中
...             break 
...
f: 1
f: 1
f: 2
f: 3
f: 5
f: 8
Generator return value: done
>>> divmod(15,2)  #先取第一个数对第二个数的整除，再取模
(7, 1)
>>> help(enumerate)
Help on class enumerate in module builtins:

class enumerate(object)
 |  enumerate(iterable, start=0)
 |
 |  Return an enumerate object.
 |
 |    iterable
 |      an object supporting iteration
 |
 |  The enumerate object yields pairs containing a count (from start, which
 |  defaults to zero) and a value yielded by the iterable argument.
 |
 |  enumerate is useful for obtaining an indexed list:
 |      (0, seq[0]), (1, seq[1]), (2, seq[2]), ...
 |
 |  Methods defined here:
 |
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |
 |  __iter__(self, /)
 |      Implement iter(self).
 |
 |  __next__(self, /)
 |      Implement next(self).
 |
 |  __reduce__(...)
 |      Return state information for pickling.
 |
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
>>> from collections import deque
>>> queue = deque(range(10))
>>> queue.append(88)
>>> queue
deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 88]) # 队列，先进先出
>>> queue.popleft()
0
>>> ll = [1,2,3,4]
>>> ll.append(8) #堆栈，后进先出
>>> ll
[1, 2, 3, 4, 8]
>>> ll.pop()
8
>>> user = ['王二狗', 25, '1994-1-1']  #这玩意儿叫unpacking(解包)
>>> user_name,user_age,user_birthday = user
>>> user_name
'王二狗'
>>> user_age
25
>>> brand = ['li','nai','a','lang'] #键key
>>> slogan = ['any','just','impossible','program'] #值value
>>> print('lang的口号是:',slogan[brand.index('lang')])
lang的口号是: program
>>> dict1 = {'li':'any','nai':'just','a':'impossible','lang':'program'} #每一个键值组合称为项
>>> print('li的口号是：',dict1['li'])
li的口号是： any
>>> dict2 = {1:'one',2:'two',3:'three'}   #字典不是数据类型 是映射类型 可以直接用大括号创建
>>> dict2[2]
'two'
>>> dict3 = dict((('f',70),('i',105)))   # 也可以用dict字符加两个小括号创建
>>> dict3
{'f': 70, 'i': 105}
>>> print('f对应的ASCII码是',dict3['f'])
f对应的ASCII码是 70
>>> dict1 = dict(小甲鱼='change world by program',北斗='change me')   #也可以用关键字参数创建
>>> dict1
{'小甲鱼': 'change world by program', '北斗': 'change me'}
>>> dict1 = {'li','nai','a','lang'}
>>> dict1
{'a', 'nai', 'li', 'lang'}
>>> dict1['li']='learn program'     #在没规定字典的键的时候直接赋值会出错
Traceback (most recent call last):
  File "<pyshell#86>", line 1, in <module>
    dict1['li']='learn program'
TypeError: 'set' object does not support item assignment
>>> dict1 = dict(小甲鱼='change world by program',me='change')
>>> dict1['me']
'change'
>>> dict1['me']='learn program'
>>> dict1
{'小甲鱼': 'change world by program', 'me': 'learn program'}
>>> dict1['i']='learn it twice'   #也可以添加项
>>> dict1
{'小甲鱼': 'change world by program', 'me': 'learn program', 'i': 'learn it twice'}
>>> dict2.fromkeys((1,2,3))  
{1: None, 2: None, 3: None}
>>> dict2
{}
>>> dict2.fromkeys((1,2,3),('one','two','three'))
{1: ('one', 'two', 'three'), 2: ('one', 'two', 'three'), 3: ('one', 'two', 'three')}
>>> dict2.fromkeys((1,2,3),'number')
{1: 'number', 2: 'number', 3: 'number'}
>>> dict2.fromkeys((1,3),'shu')
{1: 'shu', 3: 'shu'}
>>> dict1 = dict1.fromkeys (range(32),'an')
>>> dict1
{0: 'an', 1: 'an', 2: 'an', 3: 'an', 4: 'an', 5: 'an', 6: 'an', 7: 'an', 8: 'an', 9: 'an', 10: 'an', 11: 'an', 12: 'an', 13: 'an', 14: 'an', 15: 'an', 16: 'an', 17: 'an', 18: 'an', 19: 'an', 20: 'an', 21: 'an', 22: 'an', 23: 'an', 24: 'an', 25: 'an', 26: 'an', 27: 'an', 28: 'an', 29: 'an', 30: 'an', 31: 'an'}
>>> for eachkey in dict1.keys():
	print(eachkey,end = '')

	
012345678910111213141516171819202122232425262728293031
>>> for eachkey in dict1.values():
	print(eachkey,end = '')

	
anananananananananananananananananananananananananananananananan
>>> for each in dict1.items():
	print(each)

	
(0, 'an')
(1, 'an')
(2, 'an')
(3, 'an')
(4, 'an')
(5, 'an')
(6, 'an')
(7, 'an')
(8, 'an')
(9, 'an')
(10, 'an')
(11, 'an')
(12, 'an')
(13, 'an')
(14, 'an')
(15, 'an')
(16, 'an')
(17, 'an')
(18, 'an')
(19, 'an')
(20, 'an')
(21, 'an')
(22, 'an')
(23, 'an')
(24, 'an')
(25, 'an')
(26, 'an')
(27, 'an')
(28, 'an')
(29, 'an')
(30, 'an')
(31, 'an')
>>> print(dict1[31])
an
>>> print(dict1[32])
Traceback (most recent call last):
  File "<pyshell#123>", line 1, in <module> #字典中没有的键 直接访问会报错
    print(dict1[32])
KeyError: 32
>>> print(dict1.get(32))
None
>>> dict1.get(32,'no')   #可以用get访问或者赋值 而不会改变原字典
'no'
>>> 32 in dict1
False
>>> 31 in dict1
True
>>> a = {'name':'i'}
>>> b = a  #直接赋值不会受原字典改变的影响
>>> b
{'name': 'i'}
>>> a
{'name': 'i'}
>>> a = {}
>>> a
{}
>>> b
{'name': 'i'}
>>> a = b
>>> a
{'name': 'i'}
>>> b
{'name': 'i'}
>>> a.clear()  #但可以用clear字符全部清除
>>> a
{}
>>> b
{}
>>> a = {'name':'i'}
>>> b = a.copy()
>>> c = a
>>> c
{'name': 'i'}
>>> b
{'name': 'i'}
>>> id(a)
2344445484872  
>>> id(b)
2344445566632  #浅拷贝会改变id地址
>>> id(c)
2344445484872  #赋值不会改变id地址
>>> c[4] = 'four'
>>> c
{'name': 'i', 4: 'four'}
>>> b
{'name': 'i'}
>>> a
{'name': 'i', 4: 'four'}  #改变其中之一只会影响地址相同的
>>> a.pop(4)
'four'
>>> a
{'name': 'i'}
>>> a.popitem()  #这里是随机弹出
('name', 'i')
>>> a
{}
>>> a.setdefault('xiaoxiao')
>>> a
{'xiaoxiao': None}
>>> a.setdefault(5,'five') #随即放进去 字典中没有特殊的顺序
'five'
>>> a
{'xiaoxiao': None, 5: 'five'}
>>> b = {'xiaobai':'dog'}
>>> a.update(b)
>>> a
{'xiaoxiao': None, 5: 'five', 'xiaobai': 'dog'} #随机更新
>>> num = {}
>>> type(num)
<class 'dict'>
>>> num2 = {1,3}
>>> type(num2)  #如果只有值 则被当成了集合
<class 'set'>
>>> num3 = {1 : 'i',3 : 'me'}  #如果有键也有值 则是字典
>>> type(num3)
<class 'dict'>
>>> num2 = {1,2,222,2,3,}  #集合中的特性是唯一，会将重复的值去掉
>>> num2
{1, 2, 3, 222}
>>> num2[2]   #集合不可以访问单一的值
Traceback (most recent call last):
  File "<pyshell#9>", line 1, in <module>
    num2[2]
TypeError: 'set' object is not subscriptable
>>> set1 = set([1,2,3,4,5,4])
>>> set1
{1, 2, 3, 4, 5}
>>> set1 = [1,2,3,4,5,5,3,1,0]  #将列表中的重复的值去掉 以前的方法是用for循环
>>> temp = []
>>> for each in set1:
	if each not in temp:
		temp.append(each)
		
>>> temp
[1, 2, 3, 4, 5, 0]
>>> num1 = list(set(set1))   #现在可以用集合的特性 但得到的集合是无序的
>>> num1
[0, 1, 2, 3, 4, 5]
>>> 2 in num1
True
>>> '2' in num1
False
>>> num3 = frozenset([1,2,3])  #可用来创建不可变集合
>>> num3
frozenset({1, 2, 3})
>>> num3.add(4)
Traceback (most recent call last):
  File "<pyshell#32>", line 1, in <module>
    num3.add(4)
AttributeError: 'frozenset' object has no attribute 'add'



>>> def add_end(L=[]):
        L.append('END')
        return L
>>> add_end()
['END']
>>> add_end()
['END', 'END']
>>> def add_end(L=None):  #定义默认参数要牢记一点：默认参数必须指向不变对象！
    	if L is None:
            L = []
    	L.append('END')
    	    return 
>>> add_end()
['END']
>>> add_end()
['END']
>>> import math
>>> def is_square(n):
	'''函数定义过程中的n叫形参
	因为这是一个形式，表示占据一个参数位置'''
	print('传递进来的'+n+'叫做实参，因为这是具体的参数值')
        return n > -1 and math.sqrt(n) % 1 == 0 #验证是否有整数平方根的重要方法
>>> is_sqrare(5)
传递进来的+5+叫做实参，因为这是具体的参数值
False
>>> myfirstfunction.__doc__  #调用文档字符串
'函数定义过程中的name叫形参\n\t 因为这是一个形式，表示占据一个参数位置'
>>> print.__doc__
"print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream."
>>> def saysome(name,words):
	print(name+'->'+words)	
>>> saysome('i','love you')#传递(调用)参数的方法有两种,这是位置参数,即按照默认位置来调用
i->love you
>>> saysome('love you','i') 
love you->i
>>> saysome(words='love you',name='i')    #其中name,words为关键字参数,给定一个值
i->love you
>>> def saysome(name='i',words='love you'):    #其中name,words为默认参数,i,love you为默认值
	print(name+'->'+words)	
>>> saysome()
i->love you
>>> saysome('me')
me->love you
>>> saysome('she','love me')
she->love me
>>> def test(*params):    #形参前面加一个乘号为收集参数
	print('参数的长度是:',len(params));
	print('第二个参数是:',params[1]);	
>>> test(1,'小和尚',3.14,5,6,7,8)
参数的长度是: 7
第二个参数是: 小和尚
>>> def test(*params,exp):     #python默认会将乘号后面全当做收集参数
	print('参数的长度是:',len(params));
	print('第二个参数是:',params[1]);	
>>> test(1,'小和尚',3.14,5,6,7,8)
Traceback (most recent call last):
  File "<pyshell#28>", line 1, in <module>
    test(1,'小和尚',3.14,5,6,7,8)
TypeError: test() missing 1 required keyword-only argument: 'exp'
>>> test(1,'小和尚',3.14,5,6,7,8,exp=8)      #解决方法为加一个默认参数
参数的长度是: 7
第二个参数是: 小和尚
>>> def test(exp,*params):     #或者将形式参数放在前面
	print('参数的长度是:',len(params));
	print('第二个参数是:',params[1]);
	
>>> test(1,'小和尚',3.14,5,6,7,8)
参数的长度是: 6
第二个参数是: 3.14
>>> def total(a=5, *numbers, **phonebook):  #也可用双星号
	    print('a', a)

	    #iterate through all the items in tuple
	    for single_item in numbers:
		print('single_item', single_item)

	    #iterate through all the items in dictionary    
	    for first_part, second_part in phonebook.items():
		print(first_part,second_part)

>>> total(10,1,2,3,Jack=1123,John=2231,Inge=1560)
>>> a 10
single_item 1
single_item 2
single_item 3
Inge 1560
John 2231
Jack 1123
>>> def hello():
	print('hello fishc!')
	
>>> temp = hello()
hello fishc!
>>> temp
>>> print(temp)
None
>>> type(temp)
<class 'NoneType'>
>>> def back():
	return [q1,'i',3]

>>> back()
Traceback (most recent call last):
  File "<pyshell#43>", line 1, in <module>
    back()
  File "<pyshell#42>", line 2, in back
    return [q1,'i',3]
NameError: name 'q1' is not defined
>>> def back():
	return [1,'i',3.14]

>>> back()
[1, 'i', 3.14]
>>> def back():
	return 1,'i',3.14

>>> back()
(1, 'i', 3.14)
#函数定义过程中的局部变量出了函数定义过程就不可使用，而函数定义过程外的变量为全局变量
#在函数里面可以访问全局变量但不可以修改
>>> count = 5
>>> def myfun():
	count = 10
	print(10)
	
>>> print(count)
5
>>> def myfun():
	global count#如果一定要改全局变量则用global关键字
	count = 10
	print(10)
	
>>> myfun()
10
>>> print(count)
10
>>> def fun1():
	print('fun1()正在被调用...')
	def fun2():
		print('fun2()正在被调用...')
	fun2()

	
>>> fun1()
fun1()正在被调用...
fun2()正在被调用...
>>> fun2()
Traceback (most recent call last):
  File "<pyshell#37>", line 1, in <module>#内嵌函数出了定义的函数之后就不能被调用了
    fun2()
NameError: name 'fun2' is not defined
>>> def funx(x):
	def funy(y):
		return x*y  #在内部函数funy()里，引用外部作用域的变量x,则称funy()为闭包
	return funy

>>> funx(1)(3)
3
>>> i = funx(8)
>>> type(i)
<class 'function'>
>>> def fun1():
	x = 5
	def fun2():
		x*=x
		return x  #闭包里面不可以用外部作用域的变量去赋值同样的变量名
	return fun2()

>>> fun1()
Traceback (most recent call last):
  File "<pyshell#55>", line 1, in <module>
    fun1()
  File "<pyshell#54>", line 6, in fun1
    return fun2()
  File "<pyshell#54>", line 4, in fun2
    x*=x
UnboundLocalError: local variable 'x' referenced before assignment
>>> def abc():
	x = 1
	def bcd():
		x = 2
		return x   #但是可以直接赋值新的值
	return bcd()

>>> abc()
2
>>> def fun1():
	x = 5
	def fun2():
		global x   #可以用global关键字改变
		x = 1
		return x
	return fun2()

>>> fun1()
1
>>> def fun1():
	x = [5]
	def fun2():
		x[0] *= x[0]   #也可以将变量改为元组
		return x[0]
	return fun2()

>>> fun1()
25
>>> def fun1():
	x = 5
	def fun2():
		nonlocal x   #也可以运用nonlocal关键字
		x *=x
		return x
	return fun2()

>>> fun1()
25
>>> lambda x :2*x+1
<function <lambda> at 0x000001F7A96F2438>#lambda表达式可以简化函数定义过程
>>> g = lambda x :2*x+1
>>> g(5)
11
>>> h = lambda x: x%2
>>> list(filter(h,range(1,10)))#filter可以通过函数筛选可迭代区间中的值，默认筛选正数
[1, 3, 5, 7, 9]
>>> list(filter(None,[0,False,True]))
[True]
>>> list(filter(None,[0,1]))
[1]
>>> list(map(lambda x:x*2,range(10)))
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]#map可以将范围中的值带入函数中再返回值
>>> def recursion():
	return recursion()

>>> import sys
>>> sys.setrecursionlimit(100)#不可以轻易使用递归，要限制位数之后再使用
>>> def fib(n):
	if n == 0 or n==1:
		return 1
	else:
		return n*fib(n-1)#求阶乘可用递归

	
>>> fib(5)
120
>>> def fab(n):
	i = 1
	x = 1
	while i!=n:#也可用while循环
		i += 1
		x = x*i
	return x

>>> fab(5)
120
>>> def fib(n):
	result = n
	for i in range(1,n):#也可用for循环
		result *= i
	return result

>>> fib(5)
120
>>> def fib(n):    #用迭代算斐波那契
	n1 = 1
	n2 = 1
	n3 = 1
	if n == 2 or n == 1:
		return 1
	while (n-2)>0:
		n3 = n2 + n1
		n1 = n2
		n2 = n3
		n = n-1
	return n3

>>> fib(8)
21
>>> def fib(n):
	if n == 1 or n == 2:
		return 1
	else:
		return fib(n-1)+fib(n-2)

	
>>> fib(8)
21
>>> def hanoi(n,x,y,z):
	if n == 1:
		print(x,'-->',z)   
	else:
		hanoi(n-1,x,z,y)#将前n-1个盘子从x移动到y上 中间的z是借助针 xy分别为初始针和目的针
		print(x,'-->',z)#将最底下的最后一个盘子从x移动到z上
		hanoi(n-1,y,x,z)#将y上的n-1个移动到z上 x是借助针
>>> hanoi(3,'x','y','z')
x --> z
x --> y
z --> y
x --> z
y --> x
y --> z
x --> z
>>> def creatfile(name,content,censored_word='hello',changed_word='goodbye'):
	name = 'D:\\Users\\向致承\\Documents\\python\\'+name
	content = str(content.replace(censored_word,changed_word))		   
	f = open(name,'w')
	f.write(content)
	print('done')
>>> creatfile('new2','hello word')#最后结果为goodbye world
done




>>> import sys as s
>>> s.path
['', 'C:\\Users\\向致承\\AppData\\Local\\Programs\\Python\\Python37\\Lib\\idlelib', 'C:\\Users\\向致承\\AppData\\Local\\Programs\\Python\\Python37\\python37.zip', 'C:\\Users\\向致承\\AppData\\Local\\Programs\\Python\\Python37\\DLLs', 'C:\\Users\\向致承\\AppData\\Local\\Programs\\Python\\Python37\\lib', 'C:\\Users\\向致承\\AppData\\Local\\Programs\\Python\\Python37', 'C:\\Users\\向致承\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages']
>>> print(sys.argv)
['']
>>> from math import sqrt 
>>> print('square root of 16 is',sqrt(16))
square root of 16 is 4.0
>>> from math import sqrt as math_sqrt #用as重新命名模块的属性
>>> math_sqrt(144)
12.0
>>> sys.__name__
'sys'
>>> import __main__
>>> __main__.sys
<module 'sys' (built-in)>
>>> import random
>>> import math
>>> import sys
>>> import os
>>> import __main__ #该模块整合了所有已经导入的模块，表示该模块由用户独立运行
>>> __main__.sqrt(144)  #每个模块都有一个name属性，当其值是'__main__'时，表明该模块自身在运行，否则是被import导入的。
12.0
>>> if __name__ == '__main__':
    print('This program is being run by itself')  #该模块导入后可验证是否是用户独立运行的模块
else:
    print('I am being imported from another module')
   
This program is being run by itself #自己直接写一个模块直接运行就是自己的模块
>>> import pickle
>>> f = open('D:\\Users\\向致承\\Documents\\python\\note4.txt','wb') #注意是以二进制形式
>>> m = ['asf',234]
>>> pickle.dump(m,f) #调用的时候用load(f),并且文件打开的时候依然用二进制'rb'打开
>>> f.close()
#python3.3之前，要创建一个包，都提示需要__init__.py文件，可以是空的，但是不能缺少。python3.3之后可以不需要了，当然如果要使用一些初始化的数据还是要添加__init__.py文件的。调用包的方法同调用模块的方法。
>>> import io
>>> f = io.open("abc.txt", "wt", encoding="utf-8")
>>> f.write(u"Imagine non-English language here")
>>> f.close()
>>> text = io.open("abc.txt", encoding="utf-8").read()
>>> print(text)
Imagine non-English language here




>>> f = open('D:\\Users\\向致承\\Documents\\python\\8-29game.py')
>>> f
<_io.TextIOWrapper name='D:\\Users\\向致承\\Documents\\python\\8-29game.py' mode='r' encoding='cp936'>
>>> f.encoding
'cp936'
>>> f.read()
"import random\nsecret = random.randint(1,10)\nprint ('                  Game Begin                 ')\ntemp = input ('please guess a number from 1 to 10:')\np = int(temp)\nif p == secret:\n    print ('Bingo')\nelif 1<= p <= secret:\n    print ('be bigger')\nelif secret <= p <= 10:\n    print ('be smaller')\nwhile 1 <= p <= 10 and p != secret:\n    temp = input ('try it again:')\n    p = int(temp)\n    if p == secret:\n        print ('Bingo')\n    elif 1<= p <= secret:\n        print ('be bigger')\n    elif secret <= p <= 10:\n        print ('be smaller')\n    else:\n        print ('please guess from 1 to 10')\nwhile p < 1 or p > 10:\n    temp = input ('try it again from 1 to 10:')\n    p = int(temp)\n    if p == secret:\n        print ('Bingo')\n    elif 1<= p <= secret:\n        print ('be bigger')\n    elif secret <= p <= 10:\n        print ('be smaller')\nwhile 1 <= p <= 10 and p != secret:\n    temp = input ('try it again:')\n    p = int(temp)\n    if p == secret:\n        print ('Bingo')\n    elif 1<= p <= secret:\n        print ('be bigger')\n    elif secret <= p <= 10:\n        print ('be smaller')\n    else:\n        print ('please guess from 1 to 10')\nprint ('                Game Over                   ')\n"
>>> f.read()
''
>>> f.close ()
>>> f = open('D:\\Users\\向致承\\Documents\\python\\8-29game.py')
>>> f.read(5)
'锘縤mpo'
>>> f.tell()
7
>>> f.seek(45,0)
45
>>> f.readline()
')\n'
>>> f.tell()
47
>>> f.read()
"print ('                  Game Begin                 ')\ntemp = input ('please guess a number from 1 to 10:')\np = int(temp)\nif p == secret:\n    print ('Bingo')\nelif 1<= p <= secret:\n    print ('be bigger')\nelif secret <= p <= 10:\n    print ('be smaller')\nwhile 1 <= p <= 10 and p != secret:\n    temp = input ('try it again:')\n    p = int(temp)\n    if p == secret:\n        print ('Bingo')\n    elif 1<= p <= secret:\n        print ('be bigger')\n    elif secret <= p <= 10:\n        print ('be smaller')\n    else:\n        print ('please guess from 1 to 10')\nwhile p < 1 or p > 10:\n    temp = input ('try it again from 1 to 10:')\n    p = int(temp)\n    if p == secret:\n        print ('Bingo')\n    elif 1<= p <= secret:\n        print ('be bigger')\n    elif secret <= p <= 10:\n        print ('be smaller')\nwhile 1 <= p <= 10 and p != secret:\n    temp = input ('try it again:')\n    p = int(temp)\n    if p == secret:\n        print ('Bingo')\n    elif 1<= p <= secret:\n        print ('be bigger')\n    elif secret <= p <= 10:\n        print ('be smaller')\n    else:\n        print ('please guess from 1 to 10')\nprint ('                Game Over                   ')\n"
>>> list(f)
['import random\n', 'secret = random.randint(1,10)\n', "print ('                  Game Begin                 ')\n", "temp = input ('please guess a number from 1 to 10:')\n", 'p = int(temp)\n', 'if p == secret:\n', "    print ('Bingo')\n", 'elif 1<= p <= secret:\n', "    print ('be bigger')\n", 'elif secret <= p <= 10:\n', "    print ('be smaller')\n", 'while 1 <= p <= 10 and p != secret:\n', "    temp = input ('try it again:')\n", '    p = int(temp)\n', '    if p == secret:\n', "        print ('Bingo')\n", '    elif 1<= p <= secret:\n', "        print ('be bigger')\n", '    elif secret <= p <= 10:\n', "        print ('be smaller')\n", '    else:\n', "        print ('please guess from 1 to 10')\n", 'while p < 1 or p > 10:\n', "    temp = input ('try it again from 1 to 10:')\n", '    p = int(temp)\n', '    if p == secret:\n', "        print ('Bingo')\n", '    elif 1<= p <= secret:\n', "        print ('be bigger')\n", '    elif secret <= p <= 10:\n', "        print ('be smaller')\n", 'while 1 <= p <= 10 and p != secret:\n', "    temp = input ('try it again:')\n", '    p = int(temp)\n', '    if p == secret:\n', "        print ('Bingo')\n", '    elif 1<= p <= secret:\n', "        print ('be bigger')\n", '    elif secret <= p <= 10:\n', "        print ('be smaller')\n", '    else:\n', "        print ('please guess from 1 to 10')\n", "print ('                Game Over                   ')\n"]
>>> f.close()
>>> f = open('D:\\Users\\向致承\\Documents\\python\\8-29game.py')
>>> line = list(f)
>>> for each in line:
	print(each)
	
import random

secret = random.randint(1,10)

print ('                  Game Begin                 ')

temp = input ('please guess a number from 1 to 10:')

p = int(temp)

if p == secret:

    print ('Bingo')

elif 1<= p <= secret:

    print ('be bigger')

elif secret <= p <= 10:

    print ('be smaller')

while 1 <= p <= 10 and p != secret:

    temp = input ('try it again:')

    p = int(temp)

    if p == secret:

        print ('Bingo')

    elif 1<= p <= secret:

        print ('be bigger')

    elif secret <= p <= 10:

        print ('be smaller')

    else:

        print ('please guess from 1 to 10')

while p < 1 or p > 10:

    temp = input ('try it again from 1 to 10:')

    p = int(temp)

    if p == secret:

        print ('Bingo')

    elif 1<= p <= secret:

        print ('be bigger')

    elif secret <= p <= 10:

        print ('be smaller')

while 1 <= p <= 10 and p != secret:

    temp = input ('try it again:')

    p = int(temp)

    if p == secret:

        print ('Bingo')

    elif 1<= p <= secret:

        print ('be bigger')

    elif secret <= p <= 10:

        print ('be smaller')

    else:

        print ('please guess from 1 to 10')

print ('                Game Over                   ')

>>> f.seek(0,0)
0
>>> for each in f:
	print(each)

	
import random

secret = random.randint(1,10)

print ('                  Game Begin                 ')

temp = input ('please guess a number from 1 to 10:')

p = int(temp)

if p == secret:

    print ('Bingo')

elif 1<= p <= secret:

    print ('be bigger')

elif secret <= p <= 10:

    print ('be smaller')

while 1 <= p <= 10 and p != secret:

    temp = input ('try it again:')

    p = int(temp)

    if p == secret:

        print ('Bingo')

    elif 1<= p <= secret:

        print ('be bigger')

    elif secret <= p <= 10:

        print ('be smaller')

    else:

        print ('please guess from 1 to 10')

while p < 1 or p > 10:

    temp = input ('try it again from 1 to 10:')

    p = int(temp)

    if p == secret:

        print ('Bingo')

    elif 1<= p <= secret:

        print ('be bigger')

    elif secret <= p <= 10:

        print ('be smaller')

while 1 <= p <= 10 and p != secret:

    temp = input ('try it again:')

    p = int(temp)

    if p == secret:

        print ('Bingo')

    elif 1<= p <= secret:

        print ('be bigger')

    elif secret <= p <= 10:

        print ('be smaller')

    else:

        print ('please guess from 1 to 10')

print ('                Game Over                   ')
>>> f = open('D:\\Users\\向致承\\Documents\\python\\new.txt','w')   #新建了一个文件
>>> f.write('D:\\Users\\向致承\\Documents\\python\\new.txt')   #向其中写入内容
37
>>> f.close()
>>> f
<_io.TextIOWrapper name='D:\\Users\\向致承\\Documents\\python\\new.txt' mode='w' encoding='cp936'>



>>> try:
	f = open('wenjian.txt')
except OSError as reason:
	print('出错了，理由是'+str(reason)) #可以不加'as reason'

	
出错了，理由是[Errno 2] No such file or directory: 'wenjian.txt'
>>> try:
	sum = 1 + '1'
	f = open('me')
except (TypeError,OSError):
	print('出错了')

	
出错了
>>> try:
	f = open('wenjian.txt')
except TypeError as reason:
	print('出错了，理由是'+str(reason))  #如果错误类型没找到，还是会报错

	
Traceback (most recent call last):
  File "<pyshell#40>", line 2, in <module>
    f = open('wenjian.txt')
FileNotFoundError: [Errno 2] No such file or directory: 'wenjian.txt'
>>> try:
	f = open('wenjian.txt')
except TypeError as reason:
	print('出错了，理由是'+str(reason))  #如果错误类型没找到，还是会报错
finally :
	print('这一行不管是否出错都会执行')  #finally后的语句不过是否出错的会执行
	
这一行不管是否出错都会执行	
Traceback (most recent call last):
  File "<pyshell#40>", line 2, in <module>
    f = open('wenjian.txt')
FileNotFoundError: [Errno 2] No such file or directory: 'wenjian.txt'
>>> class ShortInputException(Exception):  #创建我们自己的异常类型
...     '''A user-defined exception class.'''
...     def __init__(self, length, atleast):
...         Exception.__init__(self)
...         self.length = length
...         self.atleast = atleast
...
>>> try:
...     text = input('Enter something --> ')
...     if len(text) < 3:
...         raise ShortInputException(len(text), 3) # Other work can continue as usual here
... except EOFError:
...     print('Why did you do an EOF on me?')
... except ShortInputException as ex:  #错误类别ShortInputException存储在as变量名中
...     print(('ShortInputException: The input was ' +
...            '{0} long, expected at least {1}')
...           .format(ex.length, ex.atleast))
... else:
...     print('No exception was raised.')
...
Enter something --> 'jlkjlkjk'
No exception was raised.
>>> try:
...     text = input('Enter something --> ')
...     if len(text) < 3:
...         raise ShortInputException(len(text), 3) # Other work can continue as usual here
... except EOFError:
...     print('Why did you do an EOF on me?')
... except ShortInputException as ex:
...     print(('ShortInputException: The input was ' +
...            '{0} long, expected at least {1}')
...           .format(ex.length, ex.atleast))
... else:
...     print('No exception was raised.')
...
Enter something --> a
ShortInputException: The input was 1 long, expected at least 3



>>> class student(object):
...     pass
...
>>> bart = student()  #加个对象
>>> bart
<__main__.student object at 0x000001EF7EC3DBC8>
>>> bart.name = 'jack'  #加个属性
>>> print(bart.name)
jack
>>> type(student)
<class 'type'>
>>> type(list)
<class 'type'>
>>> dir(list)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>> dir(student)  #没有定义其他内置函数
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
>>> class Robot:
    population = 0  #population是类变量
    def __init__(self, name):  #name是对象变量
        """Initializes the data."""
        self.name = name
        print("(Initializing {})".format(self.name))

        # When this person is created, the robot
        # adds to the population
        Robot.population += 1

    def die(self):
        """I am dying."""
        print("{} is being destroyed!".format(self.name))

        Robot.population -= 1

        if Robot.population == 0:
            print("{} was the last one.".format(self.name))
        else:
            print("There are still {:d} robots working.".format(
                Robot.population))

    def say_hi(self):
        """Greeting by the robot.

        Yeah, they can do that."""
        print("Greetings, my masters call me {}.".format(self.name))
    def how_many(cls):# 这是类方法(classmethod)
        """Prints the current population."""
        print("We have {:d} robots.".format(cls.population))
>>> class student:
...     def __init__(self):
...             print('__init__ is run')  #利用init方法时,第一个参数始终是self,
...
>>> jack = student()  #也就是说没有其他参数也会自动调用自己
__init__ is run
>>> class teacher(object):
...     def __init__(self,name,score):
...         self.name = name  # 因此,在__init__方法内部,就可以把各种属性绑定到self,因为self就指向创建的实例本身
...         self.score = score
...
>>> m = teacher('mark',23)
>>> m.name
'mark'
>>> m.score
23
>>> class Student(object):
	    def __init__(self, name, score):
		self.__name = name
		self.__score = score
#直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。
	    def print_score(self):
		print('%s: %s' % (self.__name, self.__score))
>>> bart = Student('Bart Simpson', 59)
>>> bart.__name  #限制访问,就在属性前面加__
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute '__name'
>>> class Student(object):
	    def __init__(self, name, score):
		self.__name = name
		self.__score = score
	    def print_score(self):
		print('%s: %s' % (self.__name, self.__score))
	    def get_name(self):  #要想访问已被限制的属性,可以创建新函数
	        return self.__name
	    def set_name(self,name):
	        self.__name = name
>>> jack = student('jack',23)
>>> print(jack.get_name())
>>> jack
>>> jack.set_name('pony')
>>> print(jack.get_name())
>>> pony
>>> class good(student): #定义的子类完全可以继承父类的所有属性,私有属性除外
	    def goodboy(self):
		print('good is %d'%(234))
>>> lucy = good('lucy',88)
>>> lucy.goodboy()
good is 234
>>> lucy.set_name('yatasha')
>>> lucy.print_score()
yatasha:8
>>> class bad(student):
	    def badboy(self):
		print('bad is %d'%(123))8
	    def print_score(self): #新定义的属性会覆盖父类的属性
       	        print('new name is %s'%(self.get_name()))#在子类里面调用父类的私有属性时,需使用定义的方法来调用
	    def new(self):
	        print('this is a new func')
>>> susan = bad('susan',67)
>>> susan.new()
this is a new func
>>> susan.print_score()
new name is susan
>>> help(issubclass) #返回'cls'是派生自另一个类还是同一个类。
Help on built-in function issubclass in module builtins:

issubclass(cls, class_or_tuple, /)
    Return whether 'cls' is a derived from another class or is the same class.
    
    A tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to
    check against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)
    or ...`` etc.

>>> help(isinstance) #判断是否是一个类的实例
Help on built-in function isinstance in module builtins:

isinstance(obj, class_or_tuple, /)
    Return whether an object is an instance of a class or of a subclass thereof.
    
    A tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to
    check against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)
    or ...`` etc.

>>> def reverse(text):
...     return text[::-1]
...
>>> def is_palindrome(text):
...     return text == reverse(text)
...
>>> something = 'str'
>>> if is_palindrome(something):
...     print('yes, it is a palindrome')
... else:
...     print('no, it is not a palindrome')
...
no, it is not a palindrome
>>> something = 'madam'
>>> if is_palindrome(something):
...     print('yes, it is a palindrome')
... else:
...     print('no, it is not a palindrome')
...
yes, it is a palindrome

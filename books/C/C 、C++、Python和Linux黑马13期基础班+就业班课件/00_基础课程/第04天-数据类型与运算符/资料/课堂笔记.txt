int a;
int int;
int const;



0 1bit
1
10
11
100

0000

0000 0000  1BYTE

大写的B代表BYTE（字节）， 小写的b代表bit（比特）

500GB

1.2Mb

表达一个容量的时候，一般用BYTE，表达网络带宽的时候一般用bit

1个DWORD等于32个bit


1k = 1024BYTE
1M = 1024K
1G = 1024M
1T = 1024G
十进制	八进制	二进制	十六进制
0	0	000	0
1	1	001	1
2	2	010	2
3	3	011	3
4	4	100	4
5	5	101	5
6	6	110	6
7	7	111	7
8	10	1000	8
9	11	1001	9
10	12	1010	a
11	13	1011	b  
12	14	1100	c
13	15	1101	d
14	16	1110	e
15	17	1111	f
16	20	10000	10
17	21	10001	11

010 101 111 010 101 111 101 010 101 111
2    5   7   2   5   7   5   2   5   7

032

11010
26

0111 1100 0001 1011 1111 0111
7     c    1   b    f    7 


4dafe1
010 011 011 010 111 111 100 001
2    3   3   2   7   7  4   1


4312653八进制
转化为十六进制是多少？

0001 0001 1001 0101 1010 1011
1     1    9    5    a     b

97十进制转化为8进制？

8   30
     3  6   6就是余数，3是商数
     0  3  
30这个十进制数转化为8进制就是36

8     97
       12   1
        1   4
        0   1
97十进制转化为8进制是141

97十进制转化为16进制是多少？0x61

    97
16   6   1
     0   6

    107
16   6   11
     0    6

6b
110 1011

用一个BYTE来表达7
0000 0111   7的原码

用一个WORD来表达7
0000 0000 0000 0111

用一个DWORD来表达7
0000 0000 0000 0000 0000 0000 0000 0111

用一个BYTE来表达-7
1000 0111   -7的原码

用一个WORD来表达-7
1000 0000 0000 0111

用一个DWORD来表达-7
1000 0000 0000 0000 0000 0000 0000 0111



用一个BYTE来表达-7
1111 1000   -7的反码

用一个WORD来表达-7
11111 1111 1111 1000

用一个DWORD来表达-7
1111 1111 1111 1111 1111 1111 1111 1000


用一个BYTE来表达-7
1111 1001   -7的补码

用一个WORD来表达-7
11111 1111 1111 1001

用一个DWORD来表达-7
1111 1111 1111 1111 1111 1111 1111 1001


-32

那么用DWORD表达，补码的二进制是多少？

16 32
   2  0
   0  2
32转化为16进制是20
1111 1111 1111 1111 1111 1111 1101 1111
1111 1111 1111 1111 1111 1111 1110 0000


1010 1010 1011 1011 1110 1111 0000 1011
1101 0101 0100 0100 0001 0000 1111 0101
5     5    4    4    1   0  f    5
-1430524149


1111 1111 1111 1111 1111 1111 1110 0000
1000 0000 0000 0000 0000 0000 0010 0000
                               2  0
-32

c语言不规定具体数据类型的大小，所以数据类型实际的大小是和系统息息相关的，在相同的系统下，相同的数据类型大小一定是一样的

0
0111 1111 1111 1111 1111 1111 1111 1111
7fffffff


1000 0000 0000 0000 0000 0000 0000 0100
1111 1111 1111 1111 1111 1111 1111 1100
7     f    f    f    f    f    f   c 

一个无符号的int最大放多大是数？
ffffffff
有符号的int
7fffffff

-5
1111 1111 1111 1111 1111 1111 1111 1011 -5的补码

1111 1111 1111 1111 1111 1111 1111 1011
f     f    f    f    f    f    f    b

-6
1000 0000 0000 0000 0000 0000 0000 0110
1111 1111 1111 1111 1111 1111 1111 1010 补码
f    f     f    f    f    f    f    a

1111 1111 1111 1111 1111 1111 1111 0101
1000 0000 0000 0000 0000 0000 0000 1011

-11


1111 1111 1111 1111 1111 1111 1111 1110
1000 0000 0000 0000 0000 0000 0000 0010



7fff
0111 1111 1111 1111

0111 1111 1111 1111 1111 1111 1111 1110


1111 1111 1111 1110


1111 1111 1111 1110  -2的补码

1111 1111 1111 1111 1111 1111 1111 1110


1 0000 0000 0000 0000 0000 0000 0000 0000

小写的a是97，大写的a是65，中间差32
32是空格的ASCII

0111 1111
0x7f = 127
-128到127之间

unsigned char 0 255

%u的意思是输出一个unsigned int类型
%lu的意思是输出一个unisgned long类型
sizeof在32位的windows返回类型是unsigned int,在64位的linux返回类型是unsigned long

'\''

c语言中两个整数相除 的结果是整数
一个浮点数和整数相除，结果是一个浮点数

%d int
%ld long
%u unsigned int
%lu unsigned long
%lx

%lld long long
%llu unsigned long long

100000

'1'  是整数1吗？不是，是一个字符，他有自己的ASCII，他的ASCII是49
'2' 50 '3' 51

100与 10 取余 = 0
99 10 取余 9


int a = 4;
a = a + 5;//a的值是9
a += 5;

a = a - 2;
a -= 2;

a = a % 2;
a %= 2;


a = a + 1;
a += 1;
a++;

a--;
a = a - 1;
a -= 1;

++a;
--a;

int a = 1;
int b = 2;
int c = 3;
int d = （(a + b） * c) * 15;

a = b = c = d;
a值和d是一样的
所有的优先级都可以通过()来强制改变

int a = 10;
int b = 20;
int c;
c = (a + b) * 2;


c = (a + b);



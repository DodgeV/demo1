* 寄存器是CPU内部最基本的存储单元，CPU对外是通过总线(地址、控制、数据)来和外部设备交互的，总线的宽度是8位，同时CPU的寄存器也是8位，则该CPU称为8位CPU，内存中不会进行运算，而是加载到寄存器中再进行运算，若是反复交互，为节省效率会用到缓存，缓存越大CPU性能越好。
* C语言所有的库函数调用，只能保证语法一致，不能保证执行结果是一致的，同样的库函数在不同的操作系统下执行结果可能不同，Unix和Linux很多库函数都支持POSIX，代码互相移植代价小，但Windows支持的比较差，代码移植较麻烦；另外操作系统编码不一样也会造成乱码，Windows--gbk/gb2312/ANSI,linux--utf-8(unicode)
* 使用某个函数`printf`前，需要包含对应头文件`#include <stdio.h>`，头文件类似于菜单，列举了菜名，函数调用相当于点菜，用`man 3 printf`可以查看头文件也可用`vi /usr/include/stdio.h`查看调用某个函数需要包含的头文件，`<>`包含系统标准的头文件，`""`包含自定义的头文件
* 编译型语言，先用`gcc`编译为`a.out`机器语言，再执行
> + 编译分为四步,可以对应分步编译,某些教材翻译会将编译和汇编先后调换
> + 预处理：展开头文件(将头文件内代码移进来)/宏替换/去掉注释/条件编译，`gcc -E XXX.c -o XXX.i`预处理之后的文件后缀名为`i`
> + 编译：检查语法，生成汇编, `gcc -S XXX.i -o XXX.s`编译后的汇编文件后缀名为`s`,也可以一步直接将C语言文件编译为汇编文件
> + 汇编：汇编代码转换机器码, `gcc -c XXX.s -o XXX.o`编译后的目标文件后缀名为`o`
> + 链接：链接到一起生成可执行程序, `gcc XXX.o -o XXX`,可以通过`ldd XXX`查看依赖的动态库,Windows可以通过`Depends.exe`
> + 也可以`gcc XXX.c -shared -o XXX.so`编译为动态库以便其它语言调用
* C语言每一句可执行行代码都用`;`结尾，且必须放在代码块里面，所有`#`开头的行都代表预编译指令，可以不用`;`结尾
* C语言的注释有两种，行注释`//要写的注释`是C标准的注释方式，块注释`/*要写的注释*/`是从C++借鉴而来
* C语言由函数组成，有且只有一个main函数，且程序运行从main函数开始，main函数由系统自动调用，不用人为调用，其他函数的调用必须放在`{}`内部
* 图形化界面框架有Qt，MFC
* C语言有32个关键字, 9个控制语句, 34种运算符
* 常量为程序运行中不允许修改的数据，而变量则可以修改，变量在使用之前必须定义标识符，并标有对应数据类型，标识符不能是关键字，只能由字母数字下划线组成，数字不能开头，区分大小写，且同一个`{}`内不能重复
* `int b;`定义变量，分配内存空间
* `extern int b;`声明变量，没有建立内存空间，不可以赋值
* `const int b = 10;`修饰一个变量为只读，不允许修改
* `int b = 10;`变量的初始化，即定义变量同时赋值
* `b = 111;`变量的赋值是在定义之后的修改
* 数据类型的作用是告诉编译器该类型的变量需要分配多少空间，来更合理的利用存储空间存储数据
> + 基本类型
> + 构造类型
> + 指针类型

```C
#include <stdio.h>
#include <stdlib.h>
#define MAX 100    //定义一个宏定义的标识符，值为100的常量，代表之后出现的MAX预处理都会替换为100

int main(int argc, char *argv[])
{
    printf("Hello C++ World before system!\n");
    system("ls -lha");   //在已经运行的程序中，执行一个外部程序(命令)
    int a = system("./a.out");
    printf("%d\n",a);
    
    return 0;   // return 0 -1 1等等皆可让程序正常结束
}
```
